/******************** (C) COPYRIGHT 2010 STMicroelectronics ********************
*
* File Name    : stmpe32m28.c
* Authors    : Sensor & MicroActuators BU - Application Team
*          : Yun Ye (yun.ye@st.com)
* Version    : V 1.0 
* Date      : 22/12/2010
* Description  : STMPE32M28 Capacitive touch screen controller (Fingertip)
*
********************************************************************************
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License version 2 as
* published by the Free Software Foundation.
*
* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
*
* THIS SOFTWARE IS SPECIFICALLY DESIGNED FOR EXCLUSIVE USE WITH ST PARTS.
*
********************************************************************************
* REVISON HISTORY
*
* VERSION | DATE   | AUTHORS       | DESCRIPTION
*
* 1.0    | 22/12/2010  | Yun Ye    | First Release
*
*******************************************************************************/
#include <linux/init.h>
#include <linux/errno.h>
#include <linux/hrtimer.h>
#include <linux/platform_device.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/input.h>
#include <linux/interrupt.h>
#include <linux/serio.h>
#include <linux/init.h>
#include <linux/delay.h>
#include <linux/ctype.h>
#include <linux/gpio.h>
#include <linux/i2c.h>
#include <linux/i2c-dev.h>

/*
 * Definitions & global arrays.
 */
#define DRIVER_DESC  "stmpe32m28 i2c touchscreen driver"
#define stmpe32m28_TS_DRV_NAME  "stmpe32m28"

#define X_AXIS_MAX    480
#define X_AXIS_MIN    0
#define Y_AXIS_MAX    272
#define Y_AXIS_MIN    0
#define PRESSURE_MIN  0
#define PRESSURE_MAX  256

#define P70_PATCH_LEN            2048
#define P70_CAM_LEN              128
#define WRITE_CHUNK_SIZE         64
#define P70_PATCH_ADDR_START     0x00410000
#define P70_CAM_ADDR_START       0x00003680
/*
 * Per-touchscreen data.
 */

static struct i2c_driver stm_ts_driver;
static struct workqueue_struct *stmtouch_wq;
static int cor_xyz[10][3];
static int prev_xyz[10][3];
static unsigned char ID_Indx[10];
static int IDj;

static u8 PatchData[2048]={0xD5, 0xFF, 0x7F, 0xE0, 0x15, 0x00, 0xBF, 0xE0, 0x95, 0x01, 0x40, 0xE1, 0xC4, 0x0C, 0x00, 0xE1, 
              0x9F, 0x03, 0xA0, 0xE0, 0x07, 0x00, 0x10, 0xE0, 0x15, 0x00, 0x40, 0xE1, 0x15, 0xF9, 0x89, 0xE1, 
              0x55, 0x00, 0x40, 0xE2, 0x10, 0xC1, 0x1B, 0xEF, 0x15, 0x06, 0x40, 0xE0, 0x04, 0x40, 0x40, 0xE2, 
              0x9E, 0xC6, 0xF7, 0xFF, 0x15, 0x00, 0x40, 0xF4, 0x10, 0x00, 0xBD, 0xF1, 0x15, 0x00, 0x40, 0xE5, 
              0x15, 0xFB, 0x89, 0xE5, 0x15, 0x00, 0x40, 0xF7, 0x15, 0x00, 0x40, 0xF6, 0x15, 0x00, 0x40, 0xF5, 
              0x15, 0x00, 0x40, 0xF3, 0x15, 0x00, 0x40, 0xF0, 0x15, 0x00, 0x40, 0xE3, 0x15, 0xF5, 0x89, 0xE3, 
              0xD5, 0xFF, 0x43, 0xE4, 0xD5, 0xFF, 0xBF, 0xE4, 0x95, 0xAA, 0xAA, 0xF1, 0x15, 0x33, 0xB3, 0xF0, 
              0x15, 0xF3, 0x89, 0xF3, 0x15, 0xFA, 0x89, 0xF5, 0x15, 0xF4, 0x89, 0xF6, 0x15, 0xF1, 0x89, 0xF7, 
              0xD5, 0xC3, 0x43, 0xEC, 0xD5, 0x3F, 0x40, 0xF2, 0x04, 0x40, 0x29, 0xF2, 0xC4, 0x40, 0x21, 0xEC, 
              0x04, 0xC0, 0x45, 0xF4, 0x04, 0x80, 0x45, 0xF4, 0x04, 0x40, 0x45, 0xF4, 0x04, 0xC0, 0x44, 0xF4, 
              0x84, 0x40, 0x21, 0xF0, 0x04, 0xC0, 0x40, 0xE4, 0x44, 0xC0, 0x40, 0xE4, 0xC4, 0xC0, 0x40, 0xE4, 
              0x44, 0x40, 0x21, 0xF1, 0x84, 0xC0, 0x40, 0xE4, 0x10, 0xC1, 0x0B, 0xEF, 0x03, 0x00, 0x10, 0xE0, 
              0x9E, 0x2B, 0xF5, 0xEF, 0x9E, 0x01, 0x00, 0xF0, 0x55, 0x00, 0x40, 0xE0, 0x15, 0x10, 0x40, 0xE2, 
              0x15, 0x5B, 0x95, 0xE2, 0x9F, 0x00, 0x20, 0xE0, 0x9F, 0x03, 0xA0, 0xE0, 0x07, 0x00, 0x10, 0xE0, 
              0x10, 0xC1, 0x1B, 0xEF, 0x1E, 0xD5, 0xF6, 0xFF, 0x15, 0x00, 0x40, 0xE0, 0x15, 0x00, 0x40, 0xE2, 
              0x15, 0x00, 0x40, 0xE3, 0x15, 0x00, 0x40, 0xE1, 0x15, 0xF3, 0x89, 0xE3, 0x10, 0xC1, 0x0B, 0xEF, 
              0x04, 0xC0, 0x40, 0xE1, 0x15, 0xF2, 0x89, 0xE2, 0x04, 0x80, 0x40, 0xE1, 0x15, 0xF1, 0x89, 0xE0, 
              0x04, 0x00, 0x40, 0xE1, 0x03, 0x00, 0x10, 0xE0, 0x9F, 0x03, 0xA0, 0xE0, 0x9E, 0x2F, 0x00, 0xF0, 
              0x15, 0x00, 0x40, 0xE1, 0x15, 0xF3, 0x89, 0xE1, 0x00, 0x40, 0x40, 0xE1, 0x58, 0x40, 0x40, 0xE0, 
              0x15, 0x10, 0x40, 0x21, 0x15, 0xCA, 0x95, 0x21, 0x5F, 0x00, 0x20, 0x20, 0x15, 0x00, 0x40, 0xE6, 
              0x15, 0xFD, 0x89, 0xE6, 0x15, 0x00, 0x40, 0xE7, 0x15, 0x0C, 0x84, 0xE7, 0x00, 0xDB, 0x81, 0xE1, 
              0xC0, 0x03, 0x98, 0xE0, 0x15, 0x10, 0x40, 0xE1, 0x15, 0xA5, 0x95, 0xE1, 0x5F, 0x00, 0x20, 0xE0, 
              0x9F, 0x03, 0xA0, 0xE0, 0xC7, 0x03, 0xC0, 0xE0, 0xD8, 0x00, 0x10, 0xE0, 0x1E, 0x0A, 0x00, 0x00, 
              0x15, 0x00, 0x40, 0xF4, 0x15, 0x00, 0x40, 0xF5, 0xD5, 0x00, 0x40, 0xF2, 0x5C, 0x05, 0x80, 0xF5, 
              0x1C, 0x03, 0x80, 0xF1, 0x11, 0x80, 0x1C, 0xF2, 0x9C, 0x04, 0x00, 0xF0, 0x15, 0xF5, 0x89, 0xF5, 
              0x15, 0xFB, 0x89, 0xF4, 0x5C, 0x06, 0x80, 0xF6, 0x1C, 0x07, 0x80, 0xF2, 0x52, 0x00, 0x08, 0xF1, 
              0x92, 0x00, 0x08, 0xE5, 0x50, 0x00, 0x08, 0xEC, 0x51, 0x45, 0x09, 0xE5, 0x11, 0x45, 0x0C, 0xF1, 
              0x18, 0x01, 0x53, 0xE0, 0x10, 0x00, 0xBB, 0xF3, 0x5E, 0x04, 0x00, 0x20, 0x92, 0x00, 0x0B, 0xE0, 
              0x52, 0x00, 0x0B, 0xE4, 0x9C, 0x04, 0x00, 0xF4, 0x11, 0x05, 0x09, 0xE4, 0x51, 0x05, 0x08, 0xE0, 
              0x40, 0x00, 0x50, 0xEC, 0x00, 0x40, 0x41, 0xF0, 0x18, 0x24, 0xD3, 0xE1, 0xDE, 0x01, 0x00, 0x60, 
              0x04, 0x40, 0x41, 0xEC, 0x44, 0x00, 0x48, 0xF0, 0x00, 0x00, 0xA1, 0xF0, 0x00, 0x40, 0xA4, 0xEC, 
              0x04, 0x40, 0x2C, 0xF0, 0x04, 0x00, 0x29, 0xEC, 0x90, 0x00, 0x09, 0xE4, 0x50, 0xC0, 0x0C, 0xEC, 
              0x50, 0x80, 0x1C, 0xF2, 0x10, 0x41, 0x09, 0xE5, 0x90, 0x40, 0x0C, 0xF1, 0xC3, 0x03, 0xC0, 0xE0, 
              0x1F, 0x00, 0x38, 0xE0, 0x9F, 0x03, 0xA0, 0xE0, 0x07, 0x00, 0x20, 0xE0, 0xC7, 0x03, 0xC0, 0xE0, 
              0x15, 0x00, 0x40, 0xF4, 0x15, 0xF1, 0x89, 0xF4, 0x00, 0x00, 0x45, 0xE2, 0x15, 0x00, 0x40, 0xF6, 
              0x18, 0x80, 0x08, 0xE0, 0x15, 0x0C, 0x84, 0xF6, 0xC0, 0x86, 0x85, 0xE4, 0x80, 0x86, 0x85, 0xE5, 
              0x15, 0x00, 0x40, 0xF5, 0x11, 0x41, 0x09, 0xE1, 0x58, 0x61, 0x68, 0xE1, 0x15, 0xFD, 0x89, 0xF5, 
              0x10, 0xC1, 0x1B, 0xEF, 0x19, 0x70, 0x00, 0xEC, 0x9E, 0x09, 0x00, 0x00, 0xDE, 0x07, 0x00, 0xA0, 
              0x1C, 0x01, 0x00, 0xF0, 0x10, 0x40, 0xBD, 0xF3, 0x12, 0x41, 0x09, 0xEC, 0x5C, 0x02, 0x80, 0xF1, 
              0x5C, 0x06, 0x80, 0xF2, 0x40, 0x86, 0x85, 0xE3, 0x00, 0x86, 0x85, 0xF1, 0x52, 0xC0, 0x10, 0xF2, 
              0x98, 0xC0, 0xD8, 0xE0, 0x18, 0xC0, 0x80, 0xF1, 0xD1, 0x40, 0x0C, 0xE3, 0x58, 0xE4, 0x60, 0xE1, 
              0x10, 0x00, 0xBB, 0xF0, 0x1E, 0x04, 0x00, 0x20, 0x51, 0x04, 0x0B, 0xE4, 0x52, 0x00, 0x09, 0xE4, 
              0x11, 0x00, 0x09, 0xE5, 0xD1, 0x04, 0x09, 0xE4, 0xDE, 0x00, 0x00, 0x40, 0x40, 0x40, 0xB1, 0xEC, 
              0x44, 0x00, 0x31, 0xEC, 0x1E, 0x02, 0x00, 0x60, 0x9C, 0x04, 0x00, 0xF4, 0x9C, 0x00, 0x80, 0xF5, 
              0x1C, 0x01, 0x80, 0xF6, 0x40, 0x40, 0xB1, 0xF6, 0x84, 0x00, 0x31, 0xF6, 0x40, 0x40, 0xB1, 0xF5, 
              0x44, 0x00, 0x29, 0xF5, 0x10, 0x04, 0x0C, 0xEC, 0x55, 0x00, 0x40, 0xF7, 0x10, 0xC1, 0x0B, 0xEF, 
              0x04, 0x00, 0x45, 0xF7, 0xC3, 0x03, 0xC0, 0xE0, 0x03, 0x00, 0x20, 0xE0, 0x9F, 0x03, 0xA0, 0xE0, 
              0x15, 0x00, 0x40, 0xE1, 0x15, 0xF2, 0x89, 0xE1, 0x00, 0x40, 0x40, 0xE1, 0xD5, 0xFF, 0x7F, 0xF0, 
              0x58, 0x40, 0x48, 0xE0, 0x15, 0x00, 0xBF, 0xF0, 0x9E, 0x02, 0x00, 0x20, 0xC0, 0x9F, 0x85, 0xE2, 
              0x58, 0x81, 0xC0, 0xF1, 0xDE, 0x01, 0x00, 0x60, 0x80, 0x01, 0x84, 0xE3, 0x80, 0x9F, 0x85, 0xF1, 
              0x12, 0xC0, 0x88, 0xE3, 0x12, 0x41, 0x14, 0xF1, 0x84, 0x01, 0x04, 0xE3, 0x5E, 0x01, 0x00, 0xE0, 
              0x80, 0x01, 0x84, 0xF2, 0x90, 0xBF, 0xA4, 0xF2, 0x84, 0x01, 0x04, 0xF2, 0x80, 0x9F, 0x85, 0xF1, 
              0x18, 0x00, 0x03, 0xE0, 0xD0, 0x43, 0xA4, 0xF0, 0xDE, 0x0B, 0x00, 0x00, 0x1C, 0x01, 0x00, 0xF0, 
              0x12, 0x41, 0x09, 0xF1, 0xDC, 0x02, 0x80, 0xF1, 0x15, 0x04, 0x40, 0xEC, 0x11, 0x04, 0x1B, 0xEC, 
              0x40, 0x86, 0x85, 0xE1, 0xDC, 0x09, 0x80, 0xF2, 0x52, 0x40, 0x10, 0xF4, 0x98, 0x40, 0xD8, 0xE0, 
              0x00, 0x86, 0x85, 0xF3, 0x18, 0x40, 0x80, 0xF1, 0x51, 0xC0, 0x0C, 0xF6, 0xD8, 0xA4, 0x65, 0xE1, 
              0x10, 0x40, 0xBC, 0xF2, 0xDE, 0x07, 0x00, 0x20, 0xD1, 0x44, 0x0C, 0xE4, 0x52, 0x00, 0x09, 0xE4, 
              0x11, 0x00, 0x09, 0xE5, 0x51, 0x05, 0x09, 0xE4, 0x1E, 0x02, 0x00, 0x40, 0x00, 0x00, 0xA1, 0xF6, 
              0x40, 0x40, 0xB1, 0xF1, 0xAB, 0x15, 0x04, 0xF6, 0x6B, 0x14, 0x03, 0xF1, 0x91, 0x45, 0x0C, 0xF1, 
              0x12, 0x41, 0x14, 0xF1, 0x44, 0x00, 0x31, 0xF1, 0x9E, 0x04, 0x00, 0x60, 0x1C, 0x05, 0x00, 0xF4, 
              0x9C, 0x00, 0x80, 0xF5, 0x9C, 0x03, 0x80, 0xF6, 0x80, 0x00, 0xB1, 0xE2, 0x40, 0x40, 0xB1, 0xE1, 
              0xAB, 0x10, 0x04, 0xE2, 0x6B, 0x10, 0x03, 0xE1, 0x91, 0x40, 0x08, 0xE1, 0x12, 0x41, 0x10, 0xE1, 
              0x84, 0x00, 0x29, 0xE1, 0x40, 0x00, 0xA9, 0xE1, 0x40, 0x40, 0xB1, 0xF6, 0x6B, 0x10, 0x04, 0xE1, 
              0xAB, 0x15, 0x03, 0xF6, 0x51, 0x80, 0x0D, 0xF6, 0x12, 0x81, 0x15, 0xF6, 0x44, 0x00, 0x29, 0xF6, 
              0x10, 0x84, 0x0C, 0xF1, 0x10, 0xC1, 0x0B, 0xEF, 0xC3, 0x03, 0xC0, 0xE0, 0x03, 0x00, 0x20, 0xE0, 
              0x9F, 0x03, 0xA0, 0xE0, 0x07, 0xC0, 0x41, 0xE0, 0x07, 0xF0, 0x13, 0xE0, 0x15, 0x00, 0x40, 0xEA, 
              0x15, 0x0C, 0x84, 0xEA, 0xC0, 0x9F, 0x82, 0xE7, 0x40, 0x9F, 0x82, 0xEA, 0x15, 0x00, 0x40, 0xF8, 
              0x10, 0xC2, 0x1B, 0xEF, 0x04, 0x00, 0x5C, 0xF8, 0x5E, 0x95, 0xF6, 0xFF, 0x18, 0xD8, 0x01, 0xE4, 
              0x15, 0x00, 0x40, 0xE9, 0x15, 0x00, 0x40, 0xE8, 0x15, 0xF4, 0x89, 0xE8, 0x15, 0xF2, 0x89, 0xE9, 
              0x10, 0x00, 0xB8, 0xE6, 0x1E, 0x14, 0x00, 0x00, 0x15, 0x00, 0x40, 0xEB, 0x15, 0xF9, 0x89, 0xEB, 
              0x00, 0xC0, 0x42, 0xEC, 0x58, 0x00, 0x4B, 0xE0, 0xDE, 0x12, 0x00, 0x20, 0x10, 0xC0, 0xBB, 0xE1, 
              0x5E, 0x28, 0xF7, 0xFF, 0x58, 0x00, 0xC8, 0xE0, 0x15, 0x00, 0x40, 0xF0, 0x1E, 0x12, 0x00, 0x60, 
              0x00, 0x00, 0x5C, 0xE0, 0x15, 0x00, 0x40, 0xFA, 0x18, 0xA0, 0x12, 0xE1, 0x15, 0x00, 0x40, 0xF9, 
              0x15, 0xFA, 0x89, 0xF0, 0x04, 0x00, 0x44, 0xE0, 0x15, 0xF5, 0x89, 0xF9, 0x15, 0xF3, 0x89, 0xFA, 
              0x1E, 0x04, 0x00, 0x00, 0x98, 0xC1, 0x41, 0xF1, 0x55, 0x00, 0x40, 0xEA, 0x9E, 0x10, 0x00, 0x20, 
              0x00, 0x00, 0x42, 0xF1, 0x92, 0x40, 0x0C, 0xF1, 0x51, 0x44, 0x0E, 0xF1, 0x04, 0x40, 0x44, 0xE0, 
              0x5E, 0x81, 0xF6, 0xFF, 0x00, 0x00, 0x42, 0xF2, 0x50, 0x80, 0x0C, 0xF2, 0x18, 0x81, 0xD4, 0xE0, 
              0x04, 0x00, 0x42, 0xF2, 0x9E, 0x0E, 0x00, 0x60, 0x04, 0x80, 0x46, 0xEA, 0x1E, 0x0B, 0x00, 0xE0, 
              0x5E, 0x7F, 0xF6, 0xFF, 0x00, 0x00, 0x42, 0xF1, 0x15, 0x00, 0x40, 0xEC, 0x50, 0x40, 0x1C, 0xE0, 
              0x18, 0x00, 0x18, 0xE0, 0x52, 0x40, 0x0C, 0xF0, 0x15, 0xFB, 0x89, 0xEC, 0x00, 0x2C, 0xB3, 0xF0, 
              0xDE, 0x06, 0x00, 0x00, 0x18, 0x40, 0xC4, 0xF1, 0x52, 0x00, 0x08, 0xE4, 0x92, 0x00, 0x08, 0xE5, 
              0x51, 0x46, 0x09, 0xE5, 0x11, 0x03, 0x09, 0xE4, 0x98, 0x40, 0x5C, 0xE0, 0xDE, 0x01, 0x00, 0x60, 
              0x00, 0x00, 0xA1, 0xF3, 0x00, 0x40, 0x41, 0xF2, 0x44, 0x00, 0x21, 0xF3, 0x90, 0x00, 0x19, 0xE4, 
              0x44, 0x40, 0x41, 0xF2, 0x10, 0x41, 0x19, 0xE5, 0x52, 0x40, 0x14, 0xE0, 0x1E, 0x03, 0x00, 0x20, 
              0x1C, 0x00, 0x00, 0xF4, 0x9C, 0x00, 0x80, 0xF5, 0x1C, 0x02, 0x80, 0xF6, 0x80, 0x10, 0xB1, 0xF7, 
              0x80, 0x50, 0x51, 0xF6, 0x40, 0x40, 0x41, 0xF4, 0x40, 0x00, 0xA1, 0xF5, 0xC4, 0x40, 0x41, 0xF6, 
              0xC4, 0x00, 0x21, 0xF7, 0x84, 0x00, 0x21, 0xF5, 0x84, 0x40, 0x41, 0xF4, 0xD5, 0xFF, 0x7F, 0xE1, 
              0x04, 0x00, 0x42, 0xF8, 0x04, 0x00, 0x2B, 0xF0, 0x55, 0x00, 0x40, 0xE0, 0x04, 0x40, 0x46, 0xE1, 
              0x5E, 0xBE, 0xFF, 0xFF, 0x04, 0x40, 0x42, 0xF8, 0x5E, 0x05, 0x00, 0xE0, 0x1E, 0x76, 0xF6, 0xFF, 
              0xDE, 0x00, 0x00, 0xE0, 0x04, 0x00, 0x42, 0xF8, 0x04, 0x40, 0x42, 0xF8, 0x10, 0x80, 0xB9, 0xE0, 
              0x9E, 0xC7, 0xFF, 0xFF, 0x10, 0xC2, 0x0B, 0xEF, 0x03, 0xF0, 0x13, 0xE0, 0x03, 0xC0, 0x41, 0xE0, 
              0x9F, 0x03, 0xA0, 0xE0, 0x04, 0x40, 0x42, 0xEA, 0x5E, 0xFE, 0xFF, 0xEF, 0x15, 0x00, 0x40, 0xE0, 
              0x04, 0x40, 0x42, 0xEA, 0x1E, 0xBA, 0xFF, 0xFF, 0x15, 0x06, 0x40, 0xE0, 0x15, 0xE2, 0x44, 0xE1, 
              0x04, 0x00, 0x42, 0xF8, 0x04, 0xC0, 0x42, 0xF8, 0xDE, 0x63, 0xF7, 0xFF, 0x04, 0x80, 0x46, 0xF8, 
              0xDE, 0xFA, 0xFF, 0xEF, 0x15, 0x00, 0x40, 0xE0, 0x15, 0xF9, 0x89, 0xE0, 0x55, 0x00, 0x40, 0xE1, 
              0x04, 0x00, 0x40, 0xE1, 0x9F, 0x03, 0xA0, 0xE0, 0x15, 0x00, 0x40, 0xE3, 0x15, 0x0C, 0x84, 0xE3, 
              0xC0, 0xDF, 0x80, 0xE3, 0x98, 0xC1, 0x00, 0xF1, 0x9E, 0x03, 0x00, 0x00, 0x15, 0x00, 0x40, 0xF0, 
              0x15, 0xF4, 0x89, 0xF0, 0x00, 0x00, 0x44, 0xF0, 0x15, 0x00, 0x40, 0xEC, 0x52, 0x00, 0x0C, 0xF0, 
              0x15, 0xFB, 0x89, 0xEC, 0x00, 0x2C, 0xB3, 0xEC, 0xD5, 0xFF, 0x7F, 0xE4, 0x12, 0x02, 0x1B, 0xE5, 
              0x15, 0x00, 0xBF, 0xE4, 0x84, 0x12, 0x01, 0xEC, 0xC4, 0x12, 0x01, 0xE5, 0x9E, 0xB0, 0xF5, 0xEF, 
              0x5E, 0xB0, 0xF5, 0xEF, 0x07, 0x00, 0x10, 0xE0, 0x10, 0xC1, 0x1B, 0xEF, 0x5E, 0xA6, 0xF2, 0xFF, 
              0x58, 0x00, 0x08, 0xE0, 0xC0, 0x03, 0x98, 0xE0, 0x9E, 0x05, 0x00, 0x00, 0x18, 0x01, 0x40, 0xE2, 
              0xD5, 0x00, 0x40, 0xE0, 0x1E, 0x04, 0x00, 0x20, 0x15, 0x06, 0x40, 0xE0, 0xDE, 0x62, 0xF7, 0xFF, 
              0x5E, 0x7C, 0xF6, 0xFF, 0x15, 0x00, 0x40, 0xE3, 0x15, 0xF9, 0x89, 0xE3, 0x15, 0x00, 0x40, 0xE1, 
              0x15, 0xF4, 0x89, 0xE1, 0x10, 0xC1, 0x0B, 0xEF, 0x15, 0x00, 0x40, 0xE2, 0x55, 0x00, 0x40, 0xE4, 
              0xD5, 0x00, 0x40, 0xE0, 0x04, 0xC0, 0x40, 0xE4, 0x04, 0x40, 0x40, 0xE2, 0x03, 0x00, 0x10, 0xE0, 
              0x9F, 0x03, 0xA0, 0xE0, 0x10, 0xC1, 0x0B, 0xEF, 0x03, 0x00, 0x10, 0xE0, 0x9F, 0x03, 0xA0, 0xE0, 
              0x55, 0x00, 0x40, 0xE0, 0x10, 0xC1, 0x0B, 0xEF, 0x03, 0x00, 0x10, 0xE0, 0x9F, 0x03, 0xA0, 0xE0, 
              0xC0, 0xC6, 0x85, 0xE2, 0xD1, 0x84, 0x00, 0xE2, 0x50, 0x80, 0x10, 0xE2, 0x12, 0x81, 0x08, 0xE4, 
              0x15, 0x10, 0x40, 0xE2, 0x15, 0xED, 0x9D, 0xE2, 0x9F, 0x00, 0x20, 0xE0, 0x9F, 0x03, 0xA0, 0xE0, 
              0x07, 0x00, 0x10, 0xE0, 0x55, 0x17, 0x40, 0xE0, 0xDE, 0x7A, 0xF7, 0xFF, 0x95, 0x17, 0x40, 0xE0, 
              0x5E, 0x7A, 0xF7, 0xFF, 0x03, 0x00, 0x10, 0xE0, 0x9F, 0x03, 0xA0, 0xE0, 0x9F, 0x03, 0xA0, 0xE0, 
              0x51, 0x00, 0xA0, 0xF2, 0x18, 0x80, 0x0C, 0xE2, 0x15, 0x00, 0x40, 0xE5, 0xDE, 0x02, 0x00, 0x00, 
              0x52, 0x00, 0x08, 0xEC, 0x11, 0x43, 0xA0, 0xEC, 0x18, 0x00, 0x43, 0xE2, 0xDE, 0x00, 0x00, 0x20, 
              0x10, 0x00, 0xBB, 0xF2, 0x5E, 0x01, 0x00, 0xE0, 0x52, 0x00, 0x18, 0xF0, 0x11, 0x44, 0xA0, 0xF0, 
              0x18, 0x00, 0x04, 0xE2, 0x10, 0x00, 0xBC, 0x92, 0x18, 0x80, 0x44, 0xE2, 0xDE, 0x08, 0x00, 0x20, 
              0x55, 0x00, 0x40, 0xF0, 0x93, 0x04, 0x28, 0xF3, 0xD5, 0x07, 0x40, 0xF1, 0xD1, 0x44, 0x1C, 0xF1, 
              0x18, 0x40, 0xDC, 0xE0, 0x10, 0x40, 0xBC, 0xE0, 0x18, 0x44, 0x54, 0xE0, 0xDE, 0x02, 0x00, 0x60, 
              0x5C, 0x01, 0x80, 0xF5, 0x1C, 0x02, 0x80, 0xF6, 0x50, 0x40, 0x0C, 0xF3, 0x50, 0xC0, 0x84, 0xF3, 
              0xDC, 0x04, 0x00, 0xF4, 0x18, 0x60, 0x00, 0xF1, 0x12, 0x20, 0x0C, 0xEC, 0xDE, 0x00, 0x00, 0x00, 
              0x50, 0x00, 0x18, 0xE0, 0x51, 0x01, 0xBB, 0xE5, 0x10, 0x40, 0xBC, 0xE0, 0x1E, 0x03, 0x00, 0x20, 
              0x9C, 0x01, 0x80, 0xF5, 0x5C, 0x02, 0x80, 0xF6, 0x15, 0x04, 0x40, 0xF3, 0x51, 0xC4, 0x1C, 0xF3, 
              0x50, 0xC0, 0x84, 0xF3, 0xDC, 0x04, 0x00, 0xF4, 0x18, 0x60, 0xC0, 0xF1, 0x12, 0x20, 0x0C, 0xEC, 
              0xDE, 0x00, 0x00, 0x60, 0x50, 0x00, 0x08, 0xE0, 0x51, 0x01, 0xBB, 0xE5, 0x91, 0x44, 0xA9, 0xF2, 
              0x18, 0x80, 0x0C, 0xE2, 0x1E, 0xF8, 0xFF, 0x0F, 0x53, 0x01, 0xB8, 0xE0, 0x9F, 0x03, 0xA0, 0xE0, 
              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

static u8 CamData[128] =  {0x44, 0x5A, 0x40, 0x80, 0xDE, 0x5B, 0x0A, 0xF0, 0x60, 0x22, 0x40, 0x80, 0x15, 0x00, 0x40, 0xE0, 
              0xB0, 0x58, 0x40, 0x80, 0x5E, 0x76, 0x0A, 0xF0, 0x68, 0x55, 0x40, 0x80, 0xDE, 0xB5, 0x0A, 0xE0, 
              0x78, 0x56, 0x40, 0x80, 0x5E, 0xAA, 0x0A, 0xE0, 0x2C, 0x71, 0x40, 0x80, 0xDE, 0x4C, 0x09, 0xF0, 
              0x34, 0x8A, 0x40, 0x80, 0xE4, 0x05, 0x41, 0x00, 0xE0, 0x31, 0x40, 0x80, 0x5E, 0x46, 0x0D, 0xE0, 
              0xB0, 0x77, 0x40, 0x80, 0x1E, 0xF1, 0x08, 0xE0, 0x84, 0x0B, 0x40, 0x80, 0xDE, 0xB5, 0x0F, 0xE0, 
              0xD4, 0x46, 0x40, 0x80, 0xC0, 0x17, 0x83, 0xE0, 0xEC, 0x39, 0x40, 0x80, 0x5E, 0xD1, 0x0C, 0xE0, 
              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}; 
          
struct stmpe32m28_ts {
  struct device *dev;
  struct i2c_client *client;
  struct input_dev *input_dev;
  struct hrtimer timer;
  struct work_struct  work;
  spinlock_t    lock;
  int reported_finger_count;
  int x;
  int y;
  int z;
  int pendown;
  int irq;
};



static int stmpe32m28_TS_read(struct i2c_client *client, unsigned char reg[], int cnum, u8 *buf, int num)
{
        struct i2c_msg xfer_msg[2];

        xfer_msg[0].addr = client->addr;
        xfer_msg[0].len = cnum;
        xfer_msg[0].flags = 0;
        xfer_msg[0].buf = reg;

        xfer_msg[1].addr = client->addr;
        xfer_msg[1].len = num;
        xfer_msg[1].flags = I2C_M_RD;
        xfer_msg[1].buf = buf;

        int i;
        i = i2c_transfer(client->adapter, xfer_msg, 2);
        return i;
}

static int stmpe32m28_write_reg_nodebug(struct stmpe32m28_ts *stmpe32m28_ts, unsigned char reg[], u8 num_com)
{
  int rc;
    
  rc = i2c_master_send(stmpe32m28_ts->client, reg, num_com);
  if(rc<0) {
    printk("stmpe32m28_write_reg: i2c_master_send failed: reg[0],[1],[2] = %X, %X, %X\n", reg[0], reg[1], reg[2]);
    return rc;
  }
  return 0;
}

static int stmpe32m28_write_reg(struct stmpe32m28_ts *stmpe32m28_ts, unsigned char reg[], u8 num_com)
{
  int rc;
    
  rc = i2c_master_send(stmpe32m28_ts->client, reg, num_com);
  if(rc<0) {
    printk("stmpe32m28_write_reg: i2c_master_send failed: reg[0],[1],[2] = %X, %X, %X\n", reg[0], reg[1], reg[2]);
    return rc;
  }
  //printk("stmpe32m28_write_reg: i2c_master_send SUCCEEDED: reg[0],[1],[2] = %X, %X, %X\n", reg[0], reg[1], reg[2]);
  return 0;
}

static u8 LoadPatch(struct stmpe32m28_ts *stmpe32m28_ts)
{
  u32 writeAddr, j = 0;
  u8 i, byteWork0[2], byteWork1[67], regAdd[3] ={0xB3, 0xB1,0};
  //u8 data[3];
  
  while (j<P70_PATCH_LEN)
  {
    writeAddr = P70_PATCH_ADDR_START + j;
    //Set debug write upper address
    byteWork0[0] = (writeAddr >> 24) & 0xFF;
    byteWork0[1] = (writeAddr >> 16) & 0xFF;
    regAdd[0] =0xB3;
    regAdd[1] =byteWork0[0];
    regAdd[2] =byteWork0[1];
    stmpe32m28_write_reg_nodebug(stmpe32m28_ts, &regAdd[0],3);
    //stmpe32m28_TS_read(stmpe32m28_ts->client, regAdd, 2, val, 2);    
    //if((I2C_Write_Data(STMPE32M28_SLAVE_ADDR, 1, &regAdd[0], 2, &byteWork0[0]))!= 0)
    //  return 1;    
    mdelay(10);  
    
    //Set lower address
    byteWork1[0]= 0xB1;
    byteWork1[1] = (writeAddr >> 8) & 0xFF;
    byteWork1[2] = writeAddr & 0xFF;

    i = 0;
    while ((j<P70_PATCH_LEN) && (i<WRITE_CHUNK_SIZE))
    {
      byteWork1[i+3] = PatchData[j]; 
      i++;
      j++;
    }

    stmpe32m28_write_reg_nodebug(stmpe32m28_ts, &byteWork1[0],67);
    //if((I2C_Write_Data(STMPE32M28_SLAVE_ADDR, 1, &regAdd[1], 66, &byteWork1[0]))!= 0)
      //return 1;    
    mdelay(10);      
    //data[0] = 0xB1; data[1] = byteWork1[1]; data[2] = byteWork1[2];    
    //stmpe32m28_TS_read(stmpe32m28_ts->client, data, 3, &byteWork1[1],65);
    //printk("Data 1=%x 2=%x 3=%x \n",byteWork1[1],byteWork1[2],byteWork1[3]);  
    //if((I2C_Read_Data(STMPE32M28_SLAVE_ADDR, 3, &data[0], 65, &byteWork1[1]))!= 0)
    //  return 1;    
  }
  return 0;
}


static u8 LoadCam(struct stmpe32m28_ts *stmpe32m28_ts)
{
  u32 writeAddr;
  u8 i, j = 0, byteWork0[2], byteWork1[67], regAdd[3] = {0xB3, 0xB1,0};
  
  while (j<P70_CAM_LEN)
  {
    writeAddr = P70_CAM_ADDR_START + j;

    //Set debug write upper address
    byteWork0[0] = (writeAddr >> 24) & 0xFF;
    byteWork0[1] = (writeAddr >> 16) & 0xFF;
    regAdd[0] = 0xB3;
    regAdd[1] = byteWork0[0];
    regAdd[2] = byteWork0[1];
    stmpe32m28_write_reg_nodebug(stmpe32m28_ts, &regAdd[0],3);
    //if((I2C_Write_Data(STMPE32M28_SLAVE_ADDR, 1, &regAdd[0], 2, &byteWork0[0]))!= 0)
    //  return 1;    
    mdelay(5);//5ms delay    

    //Set lower address
    byteWork1[0] = 0xB1;
    byteWork1[1] = (writeAddr >> 8) & 0xFF;
    byteWork1[2] = writeAddr & 0xFF;

    i = 0;
    while ((j<P70_CAM_LEN) && (i<WRITE_CHUNK_SIZE))
    {
      byteWork1[i+3] = CamData[j];
      i++;
      j++;
    }

    stmpe32m28_write_reg_nodebug(stmpe32m28_ts, &byteWork1[0],67);
    //if((I2C_Write_Data(STMPE32M28_SLAVE_ADDR, 1, &regAdd[1], 66, &byteWork1[0]))!= 0)
    //  return 1;    
    mdelay(5);//5ms delay      

  //  data[0] = 0xB1; data[1] = byteWork1[0]; data[2] = byteWork1[1];
  //  if((I2C_Read_Data(STMPE32M28_SLAVE_ADDR, 3, &data[0], 65, &byteWork1[1]))!= 0)
  //    return 1;
  }
  return 0;
}

struct B0_write {
  u8 addr;
  u8 val;
};

#define PRE_AREA_SPECIFIC_B0_WRITES   23
static struct B0_write pre_area_specific_writes[PRE_AREA_SPECIFIC_B0_WRITES] = {
  {0x04, 0x24}, // system control register
  {0x2C, 0x60}, // touch in threshold
  {0x2D, 0x00}, // touch in threshold
  {0x4E, 0x30}, // EVR1
  {0x4F, 0x00}, // EVR1
  {0x7F, 0x40}, // EVR2
  {0x70, 0x13}, // SW feature Enable Register With Peaking Enabled
  {0x63, 0x10}, // Auto Cal Interval to 50ms
  {0x64, 0x10}, // Auto Cal Sampling Time to 50ms
  {0x1C, 0x09}, // Set TS X Start Channel Register
  {0x1E, 0x08}, // Set TS Y Start Channel Register
  {0x1D, 0x07}, // Set TS X Channel Length Register
  {0x1F, 0x0A}, // Set TS Y Channel Length Register
  {0x6E, 0x01}, // Set Touch Motion Threshold
  {0x16, 0xDD}, // Set Capacitance Compensation
  {0x17, 0x8F}, // Set Integration Capacitance and T Cycle 4F
  {0x18, 0x1E}, // Set M-I Cycle
  {0x19, 0x0F}, // Set R Cycle
  {0x4A, 0x00}, // Stylus Area Threshold (to disable stylus)
  {0x7B, 0xCF}, // Set Acc to 64x  (Active)
  {0x7D, 0xCF}, // Set Acc to 64x  (Idle)
  {0x61, 0x08}, // Set Frame Rate  (Active) (value+1ms)
  {0x62, 0x08}, // Set Frame Rate  (Idle)
};

#define POST_AREA_SPECIFIC_B0_WRITES 16
static struct B0_write post_area_specific_writes[POST_AREA_SPECIFIC_B0_WRITES] = {
  {0x48, 0x40}, // Set Protocol Stylus Sensitivity
  {0x4B, 0x20}, // Set Finger Strength
  {0x4C, 0x01}, // Set Finger Strength
  {0x2E, 0x10}, // Touch in Hysteresis (TIHYS) Byte0
  {0x4D, 0x10}, // Touch Finger Area Byte0
  {0x68, 0x0F}, // Touch in Delay
  {0x69, 0x2F}, // Touch out Delay
  {0x81, 0x20}, // Set Base STD Dev1
  {0x82, 0x20}, // STD DEV Threshold
  {0x83, 0xC0}, // Enable Adaptive Filter, Bit7 Protocol, Bit6 Weight, Bit 1,0 Sample Count
  {0x84, 0x84}, // Noisy FIlter Weight , Default Filter Weight
  {0x85, 0x08}, // Coordinate Frame FIlter Weight , Bit7to4 Z Weight, Bit3to0 XY Weight
  {0x86, 0x10}, // STD DEV Threshold2
  {0x8F, 0xE0}, // Touch screen orientation
  {0x6F, 0x01}, // Set Touch Motion Threshold
  {0x32, 0x20}, // Set Touch Finger Threshold Hysteresis
};

static int init_stmpe32m28(struct stmpe32m28_ts *stmpe32m28_ts)
{
  u8 val[8];  
  u8 regAdd[7];
  int rc;  
  u8 patchConfig = 0x80;
            
  memset(regAdd, 0, sizeof(regAdd));
  memset(val, 0, sizeof(val));
  regAdd[0]=0xB0;
  regAdd[1]=0x00;
  
  mdelay(2000);
  int read_attempts;
  read_attempts = 1;
  while(stmpe32m28_TS_read(stmpe32m28_ts->client, regAdd, 2, val, 3) < 0 &&
         read_attempts <= 10){
    printk("stmpe32m28: attempt num %d to read Chip Id.\n",
           read_attempts + 1);
    rc=stmpe32m28_TS_read(stmpe32m28_ts->client, regAdd, 2, val, 3);
    mdelay(500);    
    printk("stmpe32m28: read of Chip ID, cut version = %x %x, %x\n" , val[0],
           val[1], val[2]);
    ++read_attempts;
  }
  if (!(val[0] && val[1])){
    printk("stmpe32m28: failed to read Chip ID, aborting init_stmpe32m28.\n");
    return rc;
  }
  mdelay(250);

  regAdd[0]=0x9E; //TS Soft Reset
  stmpe32m28_write_reg(stmpe32m28_ts, &regAdd[0],1);   
  mdelay(20);
  
  /*
  if( (LoadPatch(stmpe32m28_ts) == 0) && (LoadCam(stmpe32m28_ts) == 0) )
  {
    patchConfig |= 0x20;
    patchConfig |= 0x0F;
  }
  */
  
  regAdd[0]=0xB3; // Set Uppper byte Address
  regAdd[1]=0xFF;
  regAdd[2]=0xFF;  
  stmpe32m28_write_reg(stmpe32m28_ts, &regAdd[0],3);
  mdelay(20);
  
  regAdd[0]=0xB1; // Set lower byte Address
  regAdd[1]=0xFC;
  regAdd[2]=0x2F;  
  regAdd[3]=patchConfig;  //0x80
  stmpe32m28_write_reg(stmpe32m28_ts, &regAdd[0],4);
  mdelay(20);
  
  regAdd[0]=0xB0; // Set System Control Register
  regAdd[1]=0x04;
  regAdd[2]=0x24;    
  stmpe32m28_write_reg(stmpe32m28_ts, &regAdd[0],3);
  mdelay(100);

  regAdd[0] = 0xB0; // All writes below are 1 addr, 1 value
  int pre_i = 0;
  //printk("stmpe32m28: writing %d pre_area_specific registers: ...\n", PRE_AREA_SPECIFIC_B0_WRITES);
  for ( pre_i = 0; pre_i < PRE_AREA_SPECIFIC_B0_WRITES; ++pre_i ) {
    regAdd[1] = pre_area_specific_writes[pre_i].addr;
    regAdd[2] = pre_area_specific_writes[pre_i].val;
    //printk("stmpe32m28: writing 0x%X to 0x%X\n", regAdd[2], regAdd[1]);
    stmpe32m28_write_reg(stmpe32m28_ts, &regAdd[0], 3);
    mdelay(50);
  }
  //printk( "stmpe32m28: done writing pre_area_specific registers.\n" );

  regAdd[1]=0x07; //Read 0x07 to clear ISR
  rc=stmpe32m28_TS_read(stmpe32m28_ts->client, &regAdd[0], 2, &val[0], 1);  
  mdelay(20);  
  
  regAdd[0]=0x85; //Read oldest event to clear the buffer
  rc=stmpe32m28_TS_read(stmpe32m28_ts->client, &regAdd[0], 1, &val[0], 8);  
  mdelay(20);  
  
  regAdd[0]=0x81; //TS Sleep out
  regAdd[1]=0x00;  
  stmpe32m28_write_reg(stmpe32m28_ts, &regAdd[0],1);
  mdelay(20);  
  
  regAdd[0]=0x8A; //Set Area Location
  regAdd[1]=0x00;  //Touch screen size
  regAdd[2]=0x00;
  /*regAdd[3]=0x00;    
  regAdd[4]=0x28;   //640*480
  regAdd[5]=0x01;
  regAdd[6]=0xE0;  */
  /*regAdd[3]=0x00;    
  regAdd[4]=0x1E;   //480*272
  regAdd[5]=0x01;
  regAdd[6]=0x10;  
  */
  regAdd[3]=0x00;    
  regAdd[4]=0xFF;   //Full screen is used
  regAdd[5]=0xFF;
  regAdd[6]=0xFF;  
  
  stmpe32m28_write_reg(stmpe32m28_ts, &regAdd[0],7);
  mdelay(20);  
  
  regAdd[0]=0x8B; //Set Area layer
  regAdd[1]=0x00;  
  regAdd[2]=0x00;
  stmpe32m28_write_reg(stmpe32m28_ts, &regAdd[0],3);
  mdelay(20);
  
  regAdd[0]=0x8C; //Set Area Event
  regAdd[1]=0x00;  
  regAdd[2]=0x00;
  regAdd[3]=0x00;    
  regAdd[4]=0x00;  
  regAdd[5]=0x0F;
  regAdd[6]=0xFF;  
  stmpe32m28_write_reg(stmpe32m28_ts, &regAdd[0],7);
  mdelay(20);
  
  regAdd[0]=0x8D; //Set Area Touchs
  regAdd[1]=0x40;  
  regAdd[2]=0xFF;
  stmpe32m28_write_reg(stmpe32m28_ts, &regAdd[0],3);
  mdelay(20);

  regAdd[0] = 0xB0; // All writes below are 1 addr, 1 value
  int post_i = 0;
  printk("stmpe32m28: writing %d post_area_specific registers: ...\n", POST_AREA_SPECIFIC_B0_WRITES);
  for ( post_i = 0; post_i < POST_AREA_SPECIFIC_B0_WRITES; ++post_i ) {
    regAdd[1] = post_area_specific_writes[post_i].addr;
    regAdd[2] = post_area_specific_writes[post_i].val;
    printk("stmpe32m28: writing 0x%X to 0x%X\n", regAdd[2], regAdd[1]);
    stmpe32m28_write_reg(stmpe32m28_ts, &regAdd[0], 3);
    mdelay(20);
  }
  printk( "stmpe32m28: done writing post_area_specific registers.\n" );
  
  regAdd[0]=0xB0; // Still single-byte writes.
  regAdd[1]=0x57;  //Set Display Resoulution
  //regAdd[2]=0xFF;   //4095
  //regAdd[3]=0x0F;  
  //regAdd[4]=0xFF;  //4095
  //regAdd[5]=0x0F;  
  /*regAdd[2]=0x80;   //640
  regAdd[3]=0x02;  
  regAdd[4]=0xE0;   //480
  regAdd[5]=0x01;  */
  /*regAdd[2]=0xE0;   //480
  regAdd[3]=0x01;  
  regAdd[4]=0x10;   //272
  regAdd[5]=0x01;  */
  
  regAdd[2]=0x10;   //272
  regAdd[3]=0x01;  
  regAdd[4]=0xE0;   //480
  regAdd[5]=0x01;  
  
  stmpe32m28_write_reg(stmpe32m28_ts, &regAdd[0],6);  
  
  regAdd[0]=0x81; //TS Sleep out
  regAdd[1]=0x00;  
  stmpe32m28_write_reg(stmpe32m28_ts, &regAdd[0],1);
  mdelay(20);

  regAdd[0]=0x83; //TS Sense on
  regAdd[1]=0x00;  
  stmpe32m28_write_reg(stmpe32m28_ts, &regAdd[0],1);
  mdelay(20);  

/*
#ifdef LOAD_PATCH_CAM
  regAdd[0] = 0xB3; 
  regAdd[1] = regAdd[2] = 0x00;
  stmpe32m28_write_reg(stmpe32m28_ts, &regAdd[0],3);  
  mdelay(5);//5ms delay

  regAdd[0] = 0xB1; 
  regAdd[1] = 0x19; regAdd[2] = 0xB4; regAdd[3] = 0x04; regAdd[4] = 0x00; regAdd[5] = 0x00; regAdd[6] = 0x00;
  stmpe32m28_write_reg(stmpe32m28_ts, &regAdd[0],7);  
  mdelay(5);//5ms delay
#endif
*/

  /*
  regAdd[0] = 0xB0; // All reads below are 1 addr, 1 value
  printk("Reading %d post_area_specific registers: ...\n", POST_AREA_SPECIFIC_B0_WRITES);
  for ( post_i = 0; post_i < POST_AREA_SPECIFIC_B0_WRITES; ++post_i ) {
    regAdd[1] = post_area_specific_writes[post_i].addr;
    printk("read of addr %X : ", regAdd[1]);
    stmpe32m28_TS_read(stmpe32m28_ts->client, regAdd, 2, val, 1);
    mdelay(5);
    printk("%X\n", val[0]);  
  }
  printk( "Done reading post_area_specific registers.\n" );
  */

  /*
  //Testing for loading patch is done or not?(by checking version) 
  regAdd[0] = 0xB0; regAdd[1] = 0x03;
  stmpe32m28_TS_read(stmpe32m28_ts->client, regAdd, 2, val, 1);
  mdelay(5);  
  printk("patch version = %d\n", val[0]);  
  */
  printk("stmpe32m28 Initilized\n");    
  return 0;
}

static void newdata(struct stmpe32m28_ts * stmpe32m28ts, u8 id)
{
  //printk("stmpe32m28: newdata: (x,y,z,id)=(%d,%d,%d,%d)\n",stmpe32m28ts->x, stmpe32m28ts->y, stmpe32m28ts->z,id);
  input_report_abs(stmpe32m28ts->input_dev, ABS_MT_TRACKING_ID, id);
  input_report_abs(stmpe32m28ts->input_dev, ABS_MT_POSITION_X, stmpe32m28ts->x);
  input_report_abs(stmpe32m28ts->input_dev, ABS_MT_POSITION_Y, stmpe32m28ts->y);
  if (stmpe32m28ts->z) {
    input_report_abs(stmpe32m28ts->input_dev, ABS_MT_TOUCH_MAJOR, 10);
  } else {
    input_report_abs(stmpe32m28ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
  }
  //input_report_abs(stmpe32m28ts->input_dev, ABS_MT_WIDTH_MAJOR, stmpe32m28ts->z);
  input_mt_sync(stmpe32m28ts->input_dev);  
}

static enum hrtimer_restart st_ts_timer_func(struct hrtimer *timer)
{
  struct stmpe32m28_ts *stmpe32m28ts  = container_of(timer, struct stmpe32m28_ts, timer);

  queue_work(stmtouch_wq, &stmpe32m28ts->work);
  return HRTIMER_NORESTART;
}

static irqreturn_t ts_interrupt(int irq, void *handle)
{
  struct stmpe32m28_ts *stmpe32m28_ts = handle;  
  disable_irq_nosync(stmpe32m28_ts->client->irq);  
  queue_work(stmtouch_wq, &stmpe32m28_ts->work);
  
  return IRQ_HANDLED;
}

static void ts_tasklet_proc(struct work_struct *work)
{  
  struct stmpe32m28_ts *stmpe32m28ts = container_of(work, struct stmpe32m28_ts, work);
  unsigned char data[129];        
  int x, y,z;
  int rc;
  u8 status;
  u8 regAdd;
  u8 Found=0;
  u8 LeftEvent;
  u8 EventNum=0;
  u8 NumTouches=0;
  u8 EventNum2=0;
  u8 TouchID, EventID;
  u8 i,j;  
  //u8 regAdd2[2];
  //u8 val[2];
    
  data[0]=0xB0;
  data[1]=0x07;
  rc=stmpe32m28_TS_read(stmpe32m28ts->client, &data[0], 2, &status, 1);
  regAdd=0x86;  
  data[0]=0;  
  rc=stmpe32m28_TS_read(stmpe32m28ts->client, &regAdd, 1, data, 128);  
  stmpe32m28ts->pendown = 0;  
  TouchID=data[1]&0x0F;  
  do
  {              
    EventNum=0;                      
    do {    
      NumTouches=(data[1+EventNum*8]&0xF0)>>4;  
      LeftEvent=data[7+EventNum*8]&0x0F;                
      NumTouches=(data[1+EventNum*8]&0xF0)>>4;  
      TouchID=data[1+EventNum*8]&0x0F;  
      EventID=data[EventNum*8]&0x0F;  
      x=((data[4+EventNum*8]&0xF0)>>4)|((data[2+EventNum*8])<<4);      
      y=((data[4+EventNum*8]&0x0F)|((data[3+EventNum*8])<<4));
      z=data[5+EventNum*8];  
      if ((x==0) && (y==0) && (z==0) && (TouchID==0))
      {
           //printk("dumy \n");
        }
        else
      {
        cor_xyz[TouchID][0]=x;
        cor_xyz[TouchID][1]=y;
        cor_xyz[TouchID][2]=z;        
      }
      //printk("EventID=%d\n",EventID);
      if (EventID == 0x03)
      { 
        ID_Indx[IDj]=TouchID;   //Add New ID In
        IDj=IDj+1;
        //printk("num1= %d \n",IDj);
      }
      
      if (EventID==0x4) 
      {    
        input_report_abs(stmpe32m28ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
        input_report_abs(stmpe32m28ts->input_dev, ABS_MT_WIDTH_MAJOR, 0);
        input_mt_sync(stmpe32m28ts->input_dev);  
        for (j=0;j<IDj;j++)
        {
          if (ID_Indx[j]==TouchID)
          {
            do 
            {
              ID_Indx[j]=ID_Indx[j+1]; //update the Indx
              j++;
            }while(j<10);                
            j=IDj+1;
          }                            
        }    
        prev_xyz[TouchID][0]=0;
        prev_xyz[TouchID][1]=0;
        prev_xyz[TouchID][2]=0;
        if (IDj>0)
          IDj=IDj-1;
        //printk("num = %d \n",IDj);
        //printk("pen up\n");                  
      }        
      if (IDj!=NumTouches)
         IDj=NumTouches;
      if (IDj>0)
      {  
        if ((TouchID==ID_Indx[IDj-1]) && (NumTouches>0))  //Updat the information when Last ID appeared again. 
        {      
          for (i=0;i<NumTouches;i++)
          {                
            if ((prev_xyz[ID_Indx[i]][0]!=0) &&(prev_xyz[ID_Indx[i]][1]!=0) &&(prev_xyz[ID_Indx[i]][2]!=0))
            {
              stmpe32m28ts->x=(cor_xyz[ID_Indx[i]][0]*1+prev_xyz[ID_Indx[i]][0]*3)/4;
              stmpe32m28ts->y=(cor_xyz[ID_Indx[i]][1]*1+prev_xyz[ID_Indx[i]][1]*3)/4;
              stmpe32m28ts->z=(cor_xyz[ID_Indx[i]][2]*1+prev_xyz[ID_Indx[i]][2]*3)/4;
            }            
            else
            {
              stmpe32m28ts->x=cor_xyz[ID_Indx[i]][0];
              stmpe32m28ts->y=cor_xyz[ID_Indx[i]][1];
              stmpe32m28ts->z=cor_xyz[ID_Indx[i]][2];
            }            
            prev_xyz[ID_Indx[i]][0]=cor_xyz[ID_Indx[i]][0];
            prev_xyz[ID_Indx[i]][1]=cor_xyz[ID_Indx[i]][1];
            prev_xyz[ID_Indx[i]][2]=cor_xyz[ID_Indx[i]][2];
            
            //regAdd2[0] = 0xB0; regAdd2[1] = 0x1A;
            //stmpe32m28_TS_read(stmpe32m28ts->client, regAdd2, 2, val, 1);            
            newdata(stmpe32m28ts, ID_Indx[i]);
          }            
        }      
      }              
      stmpe32m28ts->reported_finger_count = NumTouches;  
      input_sync(stmpe32m28ts->input_dev);    
      //printk("sync\n");  
      EventNum++;                  
    }while((LeftEvent!=0) && (EventNum<16));          
    mdelay(1);  
    rc=stmpe32m28_TS_read(stmpe32m28ts->client, &regAdd, 1, data, 128);
    NumTouches=data[1];
    NumTouches=(data[1]&0xF0)>>4;      
    TouchID=data[1]&0x0F;
    LeftEvent=data[7]&0x0F;      
    EventID=data[0]&0x0F;    
  }while(EventID);      
  
  if (!stmpe32m28ts->irq) {
    hrtimer_start(&stmpe32m28ts ->timer, ktime_set(0, 10000000), HRTIMER_MODE_REL);      
  }
  else
  {
    enable_irq(stmpe32m28ts->client->irq);  
  }
}

static int stm_ts_probe(struct i2c_client *client, const struct i2c_device_id *idp)
{
  struct stmpe32m28_ts *stmpe32m28_ts = NULL;
  int err = 0;

  printk( "stmpe32m28: entering stm_ts_probe\n");
  if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)){
    err = EIO;
    goto fail;
  }
  
  stmpe32m28_ts = kzalloc(sizeof(struct stmpe32m28_ts), GFP_KERNEL);
  if (!stmpe32m28_ts){
    err = ENOMEM;
    goto fail;
  }
  
  INIT_WORK(&stmpe32m28_ts->work, ts_tasklet_proc);  
  
  stmpe32m28_ts->client=client;  
  i2c_set_clientdata(client,stmpe32m28_ts);
      
  stmpe32m28_ts->dev = &stmpe32m28_ts->client->dev;
  stmpe32m28_ts->input_dev = input_allocate_device();
  stmpe32m28_ts->input_dev->dev.parent = &client->dev;
  if(!stmpe32m28_ts->input_dev){
    err = ENOMEM;
    goto fail;
  }
    
  stmpe32m28_ts->input_dev->name = "stmpe32m28";
  stmpe32m28_ts->input_dev->phys = "stmpe32m28/input0";
  stmpe32m28_ts->input_dev->id.bustype = BUS_I2C;  
  stmpe32m28_ts->input_dev->id.vendor = 0x0001;
  stmpe32m28_ts->input_dev->id.product = 0x0002;
  stmpe32m28_ts->input_dev->id.version = 0x0100;

  stmpe32m28_ts->input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
  stmpe32m28_ts->input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
  set_bit(EV_SYN, stmpe32m28_ts->input_dev->evbit);  
  set_bit(EV_KEY,stmpe32m28_ts->input_dev->evbit);
  set_bit(BTN_TOUCH,stmpe32m28_ts->input_dev->keybit);
  set_bit(BTN_2,stmpe32m28_ts->input_dev->keybit);  
  set_bit(EV_ABS,stmpe32m28_ts->input_dev->evbit);
  
  input_set_abs_params(stmpe32m28_ts->input_dev, ABS_X, X_AXIS_MIN, X_AXIS_MAX, 0, 0);
  input_set_abs_params(stmpe32m28_ts->input_dev, ABS_Y, Y_AXIS_MIN, Y_AXIS_MAX, 0, 0);
  input_set_abs_params(stmpe32m28_ts->input_dev, ABS_PRESSURE, PRESSURE_MIN, PRESSURE_MAX, 0, 0);
  input_set_abs_params(stmpe32m28_ts->input_dev, ABS_MT_TRACKING_ID, 0, 10, 0, 0);
  input_set_abs_params(stmpe32m28_ts->input_dev, ABS_MT_TOUCH_MAJOR, PRESSURE_MIN, PRESSURE_MAX, 0, 0);
  input_set_abs_params(stmpe32m28_ts->input_dev, ABS_MT_WIDTH_MAJOR, PRESSURE_MIN, PRESSURE_MAX, 0, 0);  
  input_set_abs_params(stmpe32m28_ts->input_dev, ABS_MT_POSITION_X, X_AXIS_MIN, X_AXIS_MAX, 0, 0);
  input_set_abs_params(stmpe32m28_ts->input_dev, ABS_MT_POSITION_Y, Y_AXIS_MIN, Y_AXIS_MAX, 0, 0);
  
  err=input_register_device(stmpe32m28_ts->input_dev);  
  if(err) {
    goto fail;
  }

  err = init_stmpe32m28(stmpe32m28_ts);    
  if(err) {
    goto fail;
  }
  stmpe32m28_ts->irq=client->irq;  
    
  /*
  if(request_irq(stmpe32m28_ts->irq, ts_interrupt, IRQF_TRIGGER_FALLING, client->name, stmpe32m28_ts)) {
    err = -EBUSY;
    goto fail;
  }        
  */
  if (!stmpe32m28_ts->irq) {
    hrtimer_init(&stmpe32m28_ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
    stmpe32m28_ts->timer.function = st_ts_timer_func;
    hrtimer_start(&stmpe32m28_ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
  }
  return 0;
fail:
  if(stmpe32m28_ts) {
    if(stmpe32m28_ts->input_dev)
      input_free_device(stmpe32m28_ts->input_dev);
    kfree(stmpe32m28_ts);
  }
  printk("stmpe32m28: stm_ts_probe failed, err = %d\n", err);
  return err;
}

static int stm_ts_remove(struct i2c_client *client)
{
  struct stmpe32m28_ts *priv = dev_get_drvdata(&client->dev);
  printk("HELO from Remove\n"); 
  free_irq(priv->irq, priv);
  input_unregister_device(priv->input_dev);
  kfree(priv);    
  dev_set_drvdata(&client->dev, NULL);

  return 0;
}

static const struct i2c_device_id stm_ts_id[] = {
  { "stmpe32m28", 0 },
  { }
};

static struct i2c_driver stm_ts_driver = {
  .driver = {
    .name = "stmpe32m28",
  },
  .probe = stm_ts_probe,
  .remove = stm_ts_remove,
  .id_table = stm_ts_id,
};

static int __init stm_ts_init(void)
{
  printk("stmpe32m28: entering stm_ts_init\n");   
  stmtouch_wq = create_singlethread_workqueue("stmtouch_wq");
  if (!stmtouch_wq)
    return -ENOMEM;
    
  return i2c_add_driver(&stm_ts_driver);
}

static void __exit stm_ts_exit(void)
{
  
  i2c_del_driver(&stm_ts_driver);
  if (stmtouch_wq)
    destroy_workqueue(stmtouch_wq);
  printk("Hello from exit\n"); 
}

MODULE_DESCRIPTION("STM MultiTouch IC Driver");
MODULE_AUTHOR("Yun Ye <yeyunslh@gmail.com>");
MODULE_LICENSE("GPL");

module_init(stm_ts_init);
module_exit(stm_ts_exit);
